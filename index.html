// Animated Background with Circular Motion
function createAnimatedBackground() {
    const canvas = document.getElementById('hero-canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(canvas.width, canvas.height) * 0.4;

    const dataElements = [];
    const numberOfElements = 50;

    class DataElement {
        constructor(index) {
            this.angle = (index / numberOfElements) * Math.PI * 2;
            this.x = centerX + Math.cos(this.angle) * radius;
            this.y = centerY + Math.sin(this.angle) * radius;
            this.size = Math.random() * 20 + 10;
            this.speed = 0.005 + Math.random() * 0.01;
            this.type = Math.floor(Math.random() * 3); // 0: number, 1: graph, 2: symbol
            this.color = `rgba(255, 100, 50, ${Math.random() * 0.5 + 0.3})`;
            this.value = Math.floor(Math.random() * 100);
        }

        update() {
            this.angle += this.speed;
            this.x = centerX + Math.cos(this.angle) * radius;
            this.y = centerY + Math.sin(this.angle) * radius;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.font = `${this.size}px Arial`;
            
            if (this.type === 0) {
                ctx.fillText(this.value, this.x, this.y);
            } else if (this.type === 1) {
                this.drawGraph();
            } else {
                this.drawSymbol();
            }
        }

        drawGraph() {
            const points = [];
            for (let i = 0; i < 5; i++) {
                points.push({
                    x: this.x + i * 10,
                    y: this.y + Math.random() * 20 - 10
                });
            }

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.strokeStyle = this.color;
            ctx.stroke();
        }

        drawSymbol() {
            const symbols = ['Σ', 'μ', 'σ', 'Δ', '∫'];
            ctx.fillText(symbols[Math.floor(Math.random() * symbols.length)], this.x, this.y);
        }
    }

    function init() {
        for (let i = 0; i < numberOfElements; i++) {
            dataElements.push(new DataElement(i));
        }
    }

    function animate() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < dataElements.length; i++) {
            dataElements[i].update();
            dataElements[i].draw();
        }
        requestAnimationFrame(animate);
    }

    init();
    animate();

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        centerX = canvas.width / 2;
        centerY = canvas.height / 2;
        radius = Math.min(canvas.width, canvas.height) * 0.4;
        init();
    });
}

// Initialize everything
document.addEventListener('DOMContentLoaded', () => {
    createAnimatedBackground();
});
